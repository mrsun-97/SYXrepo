<h2 style="text-align:center">《并行计算》上机报告</h2>

<table>
	<tr>
		<td>姓名：</td>
		<td>孙玉鑫</td>
		<td>学号：</td>
		<td>PB16020865</td>
		<td>日期：</td>
		<td>2019/5/12</td>
	<tr/>
	<tr>
		<td>上机题目：</td>
		<td colspan="5" style="text-align:center">用OpenMP实现PSRS排序</td>
	</tr>
	<tr>
		<td rowspan="2">实验环境</td> 
		<td  colspan="2" >CPU</td>
		<td>内存</td>
		<td>操作系统</td>
		<td>软件平台</td>
	</tr>
	<tr>
		<td colspan="2">Intel i7-6700HQ ×8</td>
		<td>8G + 1G swap</td>
		<td>Arch Linux</td>
		<td>不清楚</td>
	</tr>
</table>

### 一、算法设计与分析

#### 题目： 用OpenMP实现PSRS排序



#### 算法设计：

​    给定处理器数目$N,\,\mathrm{id}=0,1,2,\cdots,N-1$，我们将长度为$\mathrm{L}$的数组分配给每个处理器，得到 $\mathrm{step}=\mathrm{round}(\frac{L}{N})$，之后每个处理器将数据分组，对位于$[\mathrm{id}*\mathrm{step},\,(\mathrm{id}+1)*\mathrm{step})$的数据进行以下操作：

+ 快速排序：每个线程调用$\mathrm{quick\_sort}()$（见头文件）对自己负责的数据进行原地排序；
+ 正则采样：每个线程计算$\mathrm{step2}=\mathrm{floor}(\frac{\mathrm{step}}{N})$，并得到所有组内下标是 $\mathrm{step2}$ 倍数的数据，然后根据自己$\mathrm{id}$写入正则采样数组 $\mathrm{reg}[N^2]$ 的相应位置。
+ 选择主元：使用语句`#pragma omp master`，使本步骤由主线程完成。主线程对数组$\mathrm{reg}$中的数据排序，然后以$N$为间隔，选出中间的$N-1$个数据，放在数组$\mathrm{reg}$的前$N-1$个位置上。
+ 主元划分：每个线程都读取上述位置的$N-1$个主元，以此将自己的数据分为$N$段，准备接下来的全局交换

​    在全局交换时，我们需要交换的每个片段长短不一，为了方便交换，定义了以下结构体：

``` c
typedef struct udfVec{        //slice of array
    data *pt;
    unsigned int len;
} Vec;
```

是一个 raw vector 指针加上长度信息。定义全局交换数组`Vec trans[N][N]`，在主元划分操作时，每个线程直接将划分好的第$j$个片段信息写入$\mathrm{trans}[j][\mathrm{id}]$中。

+ 全局交换：在上述主元划分时写操作结束后，每个线程直接读取$\mathrm{trans}[\mathrm{id}]$中的信息，计算出自己获得的数据总长，申请内存空间，将这些信息对应的片段从原数组中拷贝到本地数组中。
+ 归并排序：每个线程调用merge_sort()（见头文件），利用原数组空间，将本地数组排序并按$\mathrm{id}$顺序放回原数组中。



#### 算法分析：

​    每个线程进行快速排序与归并排序的时间平均为$O\big(\frac{L}{N}\log\frac{L}{N}\big)$， 采样、选择主元为$O(N)$，对主元的排序为$O(N^2\log{N^2)}$，主元划分操作与全局交换的复制操作为$O\big(\frac{L}{N}\big)$。

算法的总时间为 $t(L)=O\big(\frac{L}{N}\log\frac{L}{N}+N^2\log{N^2}\big)=O\big(\frac{L}{N}\log L\big)$



### 二、核心代码：

```
    data *t = A.pt + start;             //指针t用来遍历数组
    for(j=1;j<NUM_TNREADS;j++){         //主元划分,写入全局交换矩阵
        //trans[j-1][id].len = 0;
        trans[j-1][id].pt = t;          //该段首地址
        data cmp = reg[j];              //读取主元
        for( ;*t<cmp;t++){              //检查直到有大于该主元的元素，划分出一段
            //pass
        }
        trans[j-1][id].len = t-trans[j-1][id].pt;   //算出该段长度
    }
    trans[NUM_TNREADS-1][id].pt = t;
    trans[NUM_TNREADS-1][id].len = A.pt + end - t;
    #pragma omp barrier                 //等待写
    Vec B;                              //全局交换后每个线程拥有的数据
    B = vec_fuse(trans[id], NUM_TNREADS);
    //#pragma omp atom
        s[id] = B.len;
    #pragma omp barrier
```



