<h2 style="text-align:center">《并行计算》上机报告</h2>

<table>
	<tr>
		<td>姓名：</td>
		<td>孙玉鑫</td>
		<td>学号：</td>
		<td>PB16020865</td>
		<td>日期：</td>
		<td>2019/5/12</td>
	<tr/>
	<tr>
		<td>上机题目：</td>
		<td colspan="5" style="text-align:center">用OpenMP实现PSRS排序</td>
	</tr>
	<tr>
		<td rowspan="2">实验环境</td> 
		<td  colspan="2" >CPU</td>
		<td>内存</td>
		<td>操作系统</td>
		<td>软件平台</td>
	</tr>
	<tr>
		<td colspan="2">Intel i7-6700HQ ×8</td>
		<td>8G + 1G swap</td>
		<td>Arch Linux</td>
		<td>不清楚</td>
	</tr>
</table>

### 一、算法设计与分析

#### 题目： 用OpenMP实现PSRS排序



#### 算法设计：

​    给定处理器数目$N,\,\mathrm{id}=0,1,2,\cdots,N-1$，我们将长度为$\mathrm{L}$的数组分配给每个处理器，得到 $\mathrm{step}=\mathrm{round}(\frac{L}{N})$，之后每个处理器将数据分组，对位于$[\mathrm{id}*\mathrm{step},\,(\mathrm{id}+1)*\mathrm{step})$的数据进行以下操作：

+ 快速排序：每个线程调用$\mathrm{quick\_sort}()$（见头文件）对自己负责的数据进行原地排序；
+ 正则采样：每个线程计算$\mathrm{step2}=\mathrm{floor}(\frac{\mathrm{step}}{N})$，并得到所有组内下标是 $\mathrm{step2}$ 倍数的数据，然后根据自己$\mathrm{id}$写入正则采样数组 $\mathrm{reg}[N^2]$ 的相应位置。
+ 选择主元：使用语句`#pragma omp master`，使本步骤由主线程完成。主线程对数组$\mathrm{reg}$中的数据排序，然后以$N$为间隔，选出中间的$N-1$个数据，放在数组$\mathrm{reg}$的前$N-1$个位置上。
+ 主元划分：每个线程都读取上述位置的$N-1$个主元，以此将自己的数据分为$N$段，准备接下来的全局交换

​    在全局交换时，我们需要交换的每个片段长短不一，为了方便交换，定义了以下结构体：

``` c
typedef struct udfVec{        //slice of array
    data *pt;
    unsigned int len;
} Vec;
```

是一个 raw vector 指针加上长度信息。定义全局交换数组`Vec trans[N][N]`，在主元划分操作时，每个线程直接将划分好的第$j$个片段信息写入$\mathrm{trans}[j][\mathrm{id}]$中。

+ 全局交换：在上述主元划分时写操作结束后，每个线程直接读取$\mathrm{trans}[\mathrm{id}]$中的信息，计算出自己获得的数据总长，申请内存空间，将这些信息对应的片段从原数组中拷贝到本地数组中。
+ 归并排序：每个线程调用merge_sort()（见头文件），利用原数组空间，将本地数组排序并按$\mathrm{id}$顺序放回原数组中。



#### 算法分析：

​    每个线程进行快速排序与归并排序的时间平均为$O\big(\frac{L}{N}\log\frac{L}{N}\big)$， 采样、选择主元为$O(N)$，对主元的排序为$O(N^2\!\log{N^2)}$，主元划分操作与全局交换的复制操作为$O\big(\frac{L}{N}\big)$。

算法的总时间为 $t(L)=O\big(\frac{L}{N}\log\frac{L}{N}+N^2\log{N^2}\big)=O\big(\frac{L}{N}\log L\big)$



### 二、核心代码：

``` c
    data *t = A.pt + start;             //指针t用来遍历数组，开始指向数组首地址
    for(j=1;j<NUM_TNREADS;j++){         //主元划分,写入全局交换矩阵
        //trans[j-1][id].len = 0;
        trans[j-1][id].pt = t;          //该段首地址
        data cmp = reg[j];              //读取主元
        for( ;*t<cmp;t++){              //检查直到有大于该主元的元素，划分出一段
            //pass
        }
        trans[j-1][id].len = t-trans[j-1][id].pt;   //算出该段长度
    }
    trans[NUM_TNREADS-1][id].pt = t;
    trans[NUM_TNREADS-1][id].len = A.pt + end - t;
    #pragma omp barrier                 //等待写入完成
```

以上代码在主元划分时，将划分好的片段首地址和长度信息写入全局交换矩阵，是本实验最复杂的通信过程，但实际上并不难操作。

### 三、结果与分析

> icc main.c -o psrs.out -qopenmp -lm -O2 -g && ./psrs.out
>
> 随机生成的原始数据:
>
>  2259    5781    1768   -1629   -1152    4142   -1592    2207    -797    4128    4608    2585    3626    2192    5064   -1654    5644    2808    2449    4366    5150   -1294    -912    4918   4752     5186    5817    -266    4772    1982    -833     887    1620    2983    1306    2516     982    1762   -1421    2233    -253    5235   -1325    5421    1284    5787    5815     784   2451     2120    -994    1457    2875     142
>
> 分段快速排序后的数据:
>
> -1629   -1592   -1152    -797    1768    2192    2207    2259    2585    3626    4128    4142    4608    5781   -1654   -1294    -912    -266    2449    2808    4366    4752    4918    5064   5150     5186    5644    5817   -1421    -833    -253     887     982    1306    1620    1762    1982    2233    2516    2983    4772    5235   -1325    -994     142     784    1284    1457   2120     2451    2875    5421    5787    5815
>
> 全局交换后每个处理器上的数据:
>
> 1:
>  -797    -266    -253     887     982    1306     142     784    1284    1457
> 0:
> -1629   -1592   -1152   -1654   -1294    -912   -1421    -833   -1325    -994
> 2:
>  1768    2192    2207    2259    2585    2449    2808    1620    1762    1982    2233    2516    2983    2120    2451    2875
> 3:
>  3626    4128    4142    4608    5781    4366    4752    4918    5064    5150    5186    5644    5817    4772    5235    5421    5787    5815
>
> 最终结果：
>
> -1654   -1629   -1592   -1421   -1325   -1294   -1152    -994    -912    -833    -797    -266    -253     142     784     887     982    1284    1306    1457    1620    1762    1768    1982   2120     2192    2207    2233    2259    2449    2451    2516    2585    2808    2875    2983    3626    4128    4142    4366    4608    4752    4772    4918    5064    5150    5186    5235   5421     5644    5781    5787    5815    5817

可以从以上数据中观察数据的处理过程。在全局交换后，每个线程分配的数据数量不必相等。

### 四、备注：

​		在多次运行程序后，发现了一个小问题：3号线程分配到的数据一直是最多的。简单的分析可以发现，当我们正则采样时，我们取的样本是每个间隔的第一个数，是每个间隔中最小的，而且$\mathrm{step2}$是向下取整，这样使得我们的主元相对于数据的$N$-分位数偏小，因此数据有向后分配的趋势，最后都转移给了最后一个线程。

​		这个问题可以通过改变正则采样时选取每个间隔中的第几个数来解决，也可以通过改变选取主元位置的方式来解决。但不管怎么优化，由于数据的随机性，每个线程分配的数据总是会有多有少。

### 五、总结：

​		本次实验中，我通过实践学到了OpenMP的用法，通过解决具体问题，熟悉了OpenMP中各种关键字的作用。

___

源代码见附件。